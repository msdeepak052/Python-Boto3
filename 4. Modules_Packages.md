## ğŸ§  What is a Python Module?

A **module** is simply a **Python file (`.py`)** that contains **functions, variables, classes, or runnable code**.
It allows you to **organize code logically** and **reuse it** across multiple scripts or projects.

> âœ… One file = One module

---

### âœ… Why Use Modules?

| Benefit              | Explanation                                                              |
| -------------------- | ------------------------------------------------------------------------ |
| ğŸ” Reusability       | Write once, use many times                                               |
| ğŸ“¦ Organization      | Separate concerns into different files                                   |
| ğŸ› ï¸ Maintainability  | Easier to debug, update, and test                                        |
| ğŸ§ª Testability       | Functions in modules are easier to test                                  |
| â™»ï¸ DevOps Automation | You can create a module for EC2 logic, one for S3, one for logging, etc. |

---

## ğŸ”§ Types of Modules in Python

| Type             | Example                      | Description       |
| ---------------- | ---------------------------- | ----------------- |
| **Built-in**     | `os`, `sys`, `math`, `time`  | Comes with Python |
| **User-defined** | `mymodule.py`, `utils.py`    | Created by you    |
| **Third-party**  | `boto3`, `requests`, `numpy` | Installed via pip |

---

## âœ… 1. Built-in Modules

These come pre-installed with Python and can be directly imported.  
Examples:  
- `math` (mathematical operations)
- `os` (operating system interactions)
- `sys` (system-specific parameters)
- `datetime` (date and time handling)

### Example: `os` and `sys`

```python
import os
print("Current Directory:", os.getcwd())

import sys
print("Python Path:", sys.path)
```

---

## âœ… 2. User-Defined Modules

Custom modules created by developers for specific functionalities.  

### Step-by-Step Example

### File: `math_utils.py`

```python
# This is a module file

def add(x, y):
    return x + y

def multiply(x, y):
    return x * y

PI = 3.14159
```

### File: `main.py`

```python
import math_utils

print(math_utils.add(10, 5))      # 15
print(math_utils.multiply(3, 4))  # 12
print(math_utils.PI)              # 3.14159
```

---

## âœ… 3. Third-party Modules

External libraries installed via `pip` (Pythonâ€™s package manager)

```bash
pip install boto3
```
Examples:  
- `requests` (HTTP requests)
- `boto3` (AWS SDK for Python)
- `pandas` (data manipulation)


### Example:

```python
import boto3

ec2 = boto3.client('ec2')
instances = ec2.describe_instances()
print(instances)
```

âœ… Use case: AWS automation, API integrations, web frameworks, etc.

---
## **2. How to Import Modules**
There are multiple ways to import modules:

### **1. Basic Import**
```python
import math
print(math.sqrt(16))  # Output: 4.0
```

### **2. Import with Alias**
```python
import math as m
print(m.sqrt(25))  # Output: 5.0
```

### **3. Import Specific Functions**
```python
from math import sqrt, pow
print(sqrt(36))  # Output: 6.0
print(pow(2, 3))  # Output: 8.0
```

### **4. Import All Functions (Not Recommended)**
```python
from math import *  # Imports all functions
print(sqrt(49))  # Output: 7.0
```
âš ï¸ **Warning:** This can lead to naming conflicts.

---

## ğŸ” Importing Modules: Variants

| Syntax                         | Use Case                            |
| ------------------------------ | ----------------------------------- |
| `import module_name`           | Standard                            |
| `import module_name as alias`  | Shorten                             |
| `from module_name import func` | Import specific parts               |
| `from module import *`         | Import everything (not recommended) |

---

### Example:

```python
import math_utils as m

print(m.add(5, 2))

from math_utils import multiply
print(multiply(3, 4))
```

---

## ğŸ“‚ Organizing Modules in DevOps Projects

```
infra_project/
â”œâ”€â”€ ec2_module.py
â”œâ”€â”€ s3_module.py
â”œâ”€â”€ utils.py
â””â”€â”€ main.py
```

### `main.py`

```python
from ec2_module import create_instance
from s3_module import upload_file
from utils import log_event

create_instance("dev")
upload_file("logs.txt", "mybucket")
log_event("Deployment finished")
```

---

## ğŸ—‚ï¸ Special Module Parameters

### `__name__`

This is a **built-in variable** in every Python module.

```python
# mymodule.py
print("Name is", __name__)
```

When run directly:

```bash
$ python mymodule.py
# Output: Name is __main__
```

When imported:

```python
import mymodule
# Output: Name is mymodule
```

âœ… Use it to conditionally run code only when the module is the entry point.

```python
def test_func():
    print("Running test")

if __name__ == "__main__":
    test_func()  # Only runs when executed directly
```

---

## âœ… Use Case: Logging Module in DevOps

### `logger.py`

```python
def log_success(msg):
    print(f"[SUCCESS] {msg}")

def log_error(msg):
    print(f"[ERROR] {msg}")
```

### `deploy.py`

```python
from logger import log_success, log_error

log_success("Deployment complete")
log_error("Service unreachable")
```

---

## ğŸ› ï¸ Dynamic Import (Advanced Use)

You can import modules dynamically using `__import__()`:

```python
module_name = "math_utils"
mod = __import__(module_name)
print(mod.add(2, 3))
```

---
## **3. Module Search Path**
When you import a module, Python searches in the following order:
1. **Current directory**
2. **PYTHONPATH** (environment variable)
3. **Standard library directories**
4. **Site-packages** (for third-party modules)

You can check the search path using:
```python
import sys
print(sys.path)
```

## **4. Creating and Using Custom Modules**
### **Example: AWS DevOps Utility Module**
```python
# File: `aws_utils.py`
import boto3

def list_s3_buckets():
    """List all S3 buckets in AWS account"""
    s3 = boto3.client('s3')
    response = s3.list_buckets()
    return [bucket['Name'] for bucket in response['Buckets']]

def check_ec2_status(instance_id):
    """Check status of an EC2 instance"""
    ec2 = boto3.client('ec2')
    response = ec2.describe_instances(InstanceIds=[instance_id])
    return response['Reservations'][0]['Instances'][0]['State']['Name']
```

Now, import and use it:
```python
from aws_utils import list_s3_buckets, check_ec2_status

print("S3 Buckets:", list_s3_buckets())
print("EC2 Status:", check_ec2_status("i-1234567890abcdef0"))
```

---

## **5. Special Module Variables**
When a module is imported, Python defines some special variables:

| Variable | Description | Example |
|----------|-------------|---------|
| `__name__` | Name of the module | `__name__ == "__main__"` when run directly |
| `__file__` | Path of the module | `print(__file__)` â†’ `/path/to/module.py` |
| `__doc__` | Module docstring | `print(math.__doc__)` |

### **Example: `__name__` Usage**
```python
# File: `test_module.py`
def greet():
    print("Hello from module!")

if __name__ == "__main__":
    print("Running directly")
    greet()
else:
    print("Imported as a module")
```
- If run directly (`python test_module.py`), it prints:  
  ```
  Running directly
  Hello from module!
  ```
- If imported (`import test_module`), it prints:  
  ```
  Imported as a module
  ```

---

## **6. Organizing Modules into Packages**
A **package** is a collection of modules in a directory with `__init__.py`.

### **Example: AWS DevOps Package**
```
aws_devops/
â”‚
â”œâ”€â”€ __init__.py          # Marks this as a package
â”œâ”€â”€ ec2_utils.py         # EC2-related functions
â”œâ”€â”€ s3_utils.py          # S3-related functions
â””â”€â”€ lambda_utils.py      # Lambda-related functions
```

Now, you can import them as:
```python
from aws_devops import ec2_utils
from aws_devops.s3_utils import list_buckets
```

---

## **7. Reloading Modules**
If you modify a module at runtime, use `importlib.reload()`:
```python
import importlib
import aws_utils
importlib.reload(aws_utils)  # Forces re-import
```

---

## **8. Best Practices for Modules in DevOps**
1. **Modularize AWS Operations** (e.g., `ec2.py`, `s3.py`).
2. **Use `__init__.py`** to define package-level imports.
3. **Avoid Circular Imports** (Module A imports Module B, which imports Module A).
4. **Document Modules** with docstrings.
5. **Use `if __name__ == "__main__"`** for testing.

---

## **9. Real-World Example: AWS Automation Module**
```python
# File: `aws_automation.py`
import boto3

class AWSManager:
    """Handles AWS EC2 and S3 operations"""
    
    def __init__(self, region='us-east-1'):
        self.ec2 = boto3.client('ec2', region_name=region)
        self.s3 = boto3.client('s3')

    def start_ec2_instance(self, instance_id):
        """Starts an EC2 instance"""
        self.ec2.start_instances(InstanceIds=[instance_id])
        print(f"Started instance: {instance_id}")

    def upload_to_s3(self, file_path, bucket_name):
        """Uploads a file to S3"""
        self.s3.upload_file(file_path, bucket_name, file_path.split('/')[-1])
        print(f"Uploaded {file_path} to {bucket_name}")

# Usage:
if __name__ == "__main__":
    aws = AWSManager()
    aws.start_ec2_instance("i-1234567890abcdef0")
    aws.upload_to_s3("/data/logs.txt", "my-bucket")
```

---
## ğŸ“š Summary

| Feature           | Details                             |
| ----------------- | ----------------------------------- |
| What is a module? | A Python file with reusable code    |
| Types             | Built-in, User-defined, Third-party |
| How to import     | `import`, `from ... import`, `as`   |
| Main benefit      | Code reuse, separation of concerns  |
| Key use in DevOps | Organize cloud logic by service     |

---

## ğŸ§ª DevOps Real Modules You Can Build

| File           | Purpose                  |
| -------------- | ------------------------ |
| `ec2_utils.py` | Create, stop, list EC2   |
| `s3_utils.py`  | Upload, delete S3 files  |
| `k8s_utils.py` | Create pods, deploy apps |
| `logger.py`    | Logging success/fail     |
| `constants.py` | Environment configs      |

---

## ğŸ§  What is a Package in Python?

A **package** is a **collection of related modules** (Python `.py` files) organized in **directories** with an `__init__.py` file.

> âœ… In simple terms:
> **Module = one file**
> **Package = folder containing modules + `__init__.py`**

---

## âœ… Why Packages Matter

| Benefit               | Explanation                                                  |
| --------------------- | ------------------------------------------------------------ |
| ğŸ“¦ Code Organization  | Group related modules (EC2, S3, Utils)                       |
| ğŸ” Reusability        | Share and reuse common logic                                 |
| ğŸ§ª Testability        | Easier unit testing with small files                         |
| ğŸ› ï¸ DevOps Automation | Build your own libraries like `awsutils`, `monitoring`, etc. |

---

## ğŸ“‚ Package Structure Example

Letâ€™s create a package called `infra` to manage EC2 and S3:

```
infra/                   <- Package folder
â”‚
â”œâ”€â”€ __init__.py          <- Required to mark as package
â”œâ”€â”€ ec2_module.py        <- EC2 logic
â”œâ”€â”€ s3_module.py         <- S3 logic
â””â”€â”€ utils.py             <- Helper functions
```

---

## ğŸ”§ Step-by-Step Example

### `infra/ec2_module.py`

```python
def create_instance():
    return "EC2 instance created"

def stop_instance():
    return "EC2 instance stopped"
```

### `infra/s3_module.py`

```python
def upload_file(file):
    return f"Uploaded {file} to S3"
```

### `infra/utils.py`

```python
def log(msg):
    print(f"[LOG]: {msg}")
```

### `infra/__init__.py`

```python
# Can be empty or can initialize the package
print("infra package initialized")
```

### `main.py` (outside the package)

```python
from infra import ec2_module, s3_module, utils

utils.log("Starting deployment")
print(ec2_module.create_instance())
print(s3_module.upload_file("config.txt"))
```

---

## âœ… Output:

```
infra package initialized
[LOG]: Starting deployment
EC2 instance created
Uploaded config.txt to S3
```

---

## ğŸ” Importing From Packages

| Syntax                            | Explanation                    |
| --------------------------------- | ------------------------------ |
| `import package.module`           | Full import                    |
| `from package.module import func` | Specific function              |
| `from package import *`           | All modules (use with caution) |
| `import package.module as alias`  | Aliasing                       |

### Example:

```python
from infra.ec2_module import create_instance
create_instance()
```

---

## ğŸ› ï¸ What is `__init__.py`?

* A special file to tell Python the folder is a package.
* Can be **empty**, or:

  * Run setup code
  * Preload some modules
  * Define default exports

```python
# __init__.py
from .ec2_module import create_instance
```

Then in `main.py`:

```python
from infra import create_instance
print(create_instance())  # EC2 instance created
```

---

## ğŸ”Œ Relative Imports (within a package)

Inside a module, you can use:

```python
from . import utils            # current directory
from .ec2_module import stop_instance
from ..monitoring import alerts  # parent package
```

Use when you are building **large-scale internal packages**.

---

## ğŸ§ª Real DevOps Use Case

### Project Folder:

```
devops_automation/
â”œâ”€â”€ main.py
â””â”€â”€ aws/
    â”œâ”€â”€ __init__.py
    â”œâ”€â”€ ec2.py
    â”œâ”€â”€ s3.py
    â””â”€â”€ utils.py
```

### Sample Logic:

* `ec2.py` â†’ start/stop/list EC2
* `s3.py` â†’ upload/download files
* `utils.py` â†’ logs, retry logic
* `main.py` â†’ import and run above modules

---

## ğŸŒ Third-Party Packages

Installed via pip and used as full packages:

```bash
pip install boto3
```

```python
import boto3

ec2 = boto3.client("ec2")
print(ec2.describe_instances())
```

---

## ğŸ§  Best Practices

| Practice                    | Reason                                 |
| --------------------------- | -------------------------------------- |
| Use meaningful names        | `aws.ec2`, `k8s.monitoring`            |
| Keep module functions small | Easier testing and debugging           |
| Avoid circular imports      | Don't import each other back and forth |
| Use `__init__.py` wisely    | Expose only what's needed              |

---

## âœ… Summary

| Concept       | Meaning                                |
| ------------- | -------------------------------------- |
| Module        | A single `.py` file                    |
| Package       | A folder of modules with `__init__.py` |
| Import syntax | `from pkg.module import item`          |
| Use case      | Organize large DevOps/Python projects  |

---

## ğŸ” Summary Table of Package Components

| File            | Role                        |
| --------------- | --------------------------- |
| `__init__.py`   | Initializes the package     |
| `ec2_module.py` | Logic for EC2               |
| `s3_module.py`  | Logic for S3                |
| `utils.py`      | Shared logging, validation  |
| `main.py`       | Entry point using all above |

---

## Python Workspaces

Python workspaces refer to the environment in which you develop and run your Python code. They include the Python interpreter, installed libraries, and the current working directory. Understanding workspaces is essential for managing dependencies and code organization.

Python workspaces can be local or virtual environments. A local environment is the system-wide Python installation, while a virtual environment is an isolated environment for a specific project. You can create virtual environments using tools like virtualenv or venv.

Example:

```python
# Create a virtual environment
python -m venv myenv

# Activate the virtual environment (on Windows)
myenv\Scripts\activate

# Activate the virtual environment (on macOS/Linux)
source myenv/bin/activate
```

# Create a virtual environment
python -m venv myenv

# Activate the virtual environment (on Windows)
myenv\Scripts\activate

# Activate the virtual environment (on macOS/Linux)
source myenv/bin/activate

Once activated, you work in an isolated workspace with its Python interpreter and library dependencies.
